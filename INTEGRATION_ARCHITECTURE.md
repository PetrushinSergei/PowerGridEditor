# Интеграция расчёта потокораспределения в единое WinForms-приложение

## 1) Архитектурное решение

### Целевой принцип
`PowerGridEditorTool2` должен стать **единым исполняемым процессом**, где редактор схемы, опрос Modbus и расчёт Ньютона–Рафсона работают как отдельные модули внутри одной архитектуры, а не через запуск внешнего `ConsoleApplication1`.

### Рекомендуемая модульная схема
- **Domain (модель сети):** узлы, ветви, шунты, типы узлов, электрические параметры, координаты и метаданные источника данных (константа/Modbus).
- **State Store (единое состояние):** центральный объект состояния сети и расчётных результатов с версионностью (ревизией изменений).
- **Calculation Engine (встроенный solver):** C#-модуль, реализующий текущий алгоритм Ньютона–Рафсона (порт из C++), принимает снимок доменной модели и возвращает структурированный результат (напряжения, углы, потоки, потери, статус сходимости).
- **Modbus Service:** фоновый сервис опроса, обновляющий только те параметры, которые помечены как external/RT.
- **Application Services:** оркестрация сценариев “изменение данных”, “запуск расчёта”, “обновление UI”, “сохранение/загрузка”.
- **UI слой (WinForms):** только представление и команды пользователя; без тяжёлой бизнес-логики и без блокирующих расчётов.

### Почему это правильно
- Убирается хрупкая файловая/процессная интеграция между C++ и WinForms.
- У расчёта появляется строгий контракт входа/выхода, что упрощает тестирование и диагностику.
- UI не зависит от деталей solver и может безопасно обновляться по событиям.
- Modbus и ручное редактирование становятся равноправными источниками изменений в одной модели данных.

### Принципы интеграции solver
- Переносить не “консольное приложение”, а **ядро алгоритма**.
- Разделить: подготовка матриц, итерационный цикл, критерии сходимости, пост-обработка.
- Ввести объект `CalculationRequest` (снимок сети) и `CalculationResult` (структурированный ответ + диагностические флаги).
- Выполнять расчёт в фоновом потоке (Task), UI-обновление — только через UI dispatcher.

## 2) Рабочая логика и порядок действий

### Событийная модель «грязного состояния» (dirty flag)
Нужен механизм “данные изменились” с фиксацией источника и ревизии:
- `TopologyChanged` — добавление/удаление/переподключение элементов.
- `ParametersChanged` — изменение электрических параметров пользователем.
- `TelemetryChanged` — пришли новые значения Modbus.

Каждое изменение увеличивает `NetworkRevision` и помечает расчёт как устаревший.

### Логика кнопки «Рассчитать»
1. Пользователь нажимает «Рассчитать».
2. Приложение сравнивает `LastCalculatedRevision` и текущую `NetworkRevision`.
3. Если ревизия не изменилась — повторный расчёт не выполнять (или выполнять по явной опции “форсировать”).
4. Если изменилась — берётся атомарный snapshot сети и запускается solver в фоне.
5. После завершения:
   - если расчёт успешен — обновить результаты в Store и визуализацию;
   - если не сошёлся/ошибка — показать статус и диагностику в отдельной панели.

### Поведение при Modbus
- Modbus-обновления не должны автоматически пересчитывать модель на каждый пакет.
- Нужен дебаунс/батчинг (короткое окно агрегации), чтобы не запускать solver слишком часто.
- Кнопка «Рассчитать» использует уже накопленный актуальный snapshot.

### Отображение результатов
- Результаты должны отображаться в трёх местах:
  1) на схеме (подписи/цвета/иконки состояния),
  2) в табличной панели (узлы/ветви),
  3) в диагностической панели (итерации, невязка, сходимость, время расчёта).
- Старые результаты визуально помечать как “устаревшие”, если сеть изменилась после расчёта.

## 3) Исправление UI-багов: несколько окон одновременно

### Причина типичного ограничения
Обычно проблема возникает, когда дочерние формы открываются через `ShowDialog()` (модально) или форма переиспользуется как singleton с блокировкой повторного открытия.

### Рекомендованное поведение
- Для карточек узлов/ветвей/шунтов использовать **немодальные окна** (`Show()`), чтобы пользователь мог открыть несколько сущностей одновременно.
- Ввести `WindowManager`:
  - регистрирует открытые окна по ключу сущности,
  - предотвращает дубли одного и того же окна сущности,
  - позволяет открыть разные сущности параллельно,
  - корректно освобождает подписки при закрытии.
- Для снижения хаоса: поддержать каскад/тайлинг и быстрый переход к уже открытому окну.

### Потокобезопасность UI
- Все обновления контролов — только в UI-потоке.
- Фоновые задачи (Modbus/solver) публикуют события через безопасный marshaling.

## 4) Сохранение состояния: параметры + координаты

### Что сохранять
В сериализуемой модели добавить:
- для каждого графического элемента `X`, `Y`;
- при необходимости `Scale`, `CanvasOffset`/`Viewport` (если есть панорамирование/зум);
- версию формата файла (`SchemaVersion`) для обратной совместимости.

### Правила загрузки
- Загружать сначала доменные данные, затем layout-слой (координаты).
- Если координаты отсутствуют (старый файл), применять авто-раскладку по умолчанию.
- После загрузки — один полный `Invalidate/Redraw`, без частых перерисовок в цикле.

### Практическая мотивация
- Пользователь возвращается к той же визуальной картине сети.
- Уменьшается риск ошибок оператора из-за “прыгающих” элементов после импорта.

## 5) UI-дополнения и панель управления

### 5.1 Настройки сетевого адаптера (IP/маска/шлюз)
Сделать отдельный блок “Сеть/Коммуникации”:
- выбор адаптера из списка,
- поля IP/Mask/Gateway,
- кнопки “Применить”, “Проверить доступность”, “Откатить”.

Важно разделить режимы:
- **Мониторинг/отображение** (безопасно, всегда доступно),
- **Изменение конфигурации ОС** (только при повышенных правах, с подтверждением).

Обязательно:
- валидация адресов и подсети до применения,
- журнал изменений с отметкой времени и пользователя,
- явный статус результата применения (успех/ошибка/частично).

### 5.2 Текущее системное время
- Постоянная зона в статус-баре: `HH:mm:ss`.
- Обновление таймером 1 Гц.
- Для инженерных задач полезно рядом показывать timezone/UTC offset.

### 5.3 Индивидуальный интервал опроса Modbus для каждого узла
- В параметрах узла добавить `PollingIntervalMs`.
- Планировщик Modbus должен учитывать индивидуальные интервалы и приоритеты.
- Минимальные/максимальные пределы интервала задать политикой (например, защита от чрезмерной частоты).
- В UI показывать “последний успешный опрос” и “просрочку” по каждому узлу.

## 6) Рекомендованный план внедрения по этапам

1. **Этап 1 — Домен и контракты:** унификация модели сети, ввод request/result, ревизий и dirty-механизма.
2. **Этап 2 — Порт solver в C#:** перенос вычислительного ядра с тестами эквивалентности против эталонных кейсов C++.
3. **Этап 3 — Оркестрация и фоновые задачи:** запуск расчёта по кнопке с проверкой ревизий, интеграция Modbus update pipeline.
4. **Этап 4 — UI-многокошечность:** немодальные карточки + WindowManager.
5. **Этап 5 — Persistence layout:** координаты, версия формата, обратная совместимость.
6. **Этап 6 — Панель эксплуатации:** сетевой адаптер, системное время, индивидуальные интервалы опроса.

## 7) Критерии готовности (Definition of Done)

- Расчёт выполняется внутри WinForms-приложения без внешнего процесса.
- Данные из редактора и Modbus попадают в единый Store и учитываются в расчёте.
- Повторный запуск без изменений не выполняет лишний solver run.
- Можно одновременно открыть несколько окон редактирования разных сущностей.
- Файл проекта сохраняет и восстанавливает координаты схемы.
- UI содержит блок сетевых настроек, часы и настройку индивидуального polling для узлов.
- Для расчёта и сериализации есть регрессионные проверки на стабильность результатов.
